# -*- coding: utf-8 -*-
"""
    glia.myelin
    ~~~~~

    Implements Myelin API.

    :copyright: (c) 2013 by Vincent Ahrend.
"""

from glia import app, db
from glia.models import DBVesicle, Persona
from glia.views import error_message 
from nucleus import ERROR, InvalidSignatureError
from nucleus.vesicle import Vesicle

from flask import request, Response, jsonify
from flask.ext.sqlalchemy import models_committed

# Results returned per page
PER_PAGE = 50

def get_vesicle_or_error(vesicle_id):
    """
    Return a Vesicle in JSON format or an error message

    Parameters:
        vesicle_id (str): ID of the Vesicle to be returned

    Returns:
        Response object containing a JSON encoded dictionary. It has a key
        `vesicles` containing a list with the JSON encoded Vesicle as its value
    """
    v = DBVesicle.query.get(vesicle_id)
    
    if v is None:
        app.logger.warning("Requested <Vesicle [{}]> could not be found".format(vesicle_id[:6]))
        return error_message([ERROR["OBJECT_NOT_FOUND"](vesicle_id)])
    else:
        return jsonify({
            "vesicles": [v.json, ]
        })

def store_vesicle_or_error(vesicle_json):
    """
    Store a vesicle in the database and return a JSON response

    Parameters:
        vesicle_json (str): JSON encoded Vesicle to be stored

    Returns:
        Response object containing a JSON encoded dictionary. It has a key
        `vesicles` containing a list with the stored Vesicle as its value
    """  
    try:
        v = Vesicle.read(vesicle_json)
    except InvalidSignatureError, e:
        app.logger.error("Error loading vesicle: {}".format(e))
        return error_message([ERROR["INVALID_SIGNATURE"]])
    except ValueError, e:
        app.logger.error("Error loading vesicle JSON: {}".format(e))
        return error_message([ERROR["PROTOCOL_UNSUPPORTED"], ])
    except KeyError, e:
        app.logger.error("Missing key for loading vesicle JSON: {}".format(e))
        return error_message([ERROR["MISSING_KEY"](e)])

    # Store new Vesicle using the json generated by the sender
    v.save(json=vesicle_json)

    # TODO: Queue recipient notifications
    return jsonify({
        "vesicles": [vesicle_json, ]
        })

@app.route('/v0/myelin/vesicles/<vesicle_id>/', methods=["GET", "PUT"])
def vesicles(vesicle_id):
    """Manage notification vesicles"""
    # Just return the vesicle for GET request
    if request.method == "GET":
        return get_vesicle_or_error(vesicle_id)

    # For PUT request: store the enclosed vesicle in the database
    elif request.method == "PUT":
        # Validate request
        if "vesicles" not in request.json or not isinstance(request.json["vesicles"], list) or len(request.json["vesicles"]) == 0:
            app.logger.error("Malformed request: {}".format(request.json))
            return error_message([ERROR["MISSING_KEY"]("vesicles")])

        vesicle_json = request.json["vesicles"][0]
        return store_vesicle_or_error(vesicle_json)

@app.route('/v0/myelin/recipient/<recipient_id>/', methods=["GET"])
def recipient(recipient_id):
    """Return vesicles with a specific recipient"""
    recipient = Persona.query.get(recipient_id)
    page = 1

    # Recipient not found
    if recipient is None:
        return error_message(ERROR["OBJECT_NOT_FOUND"]("<Persona [{}]>".format(recipient)))

    # Inbox is empty
    if recipient.inbox is None:
        return jsonify({"vesicles": []})

    index_start = (page-1) * PER_PAGE
    index_stop = (page * PER_PAGE) - 1
    resp = {"vesicles": [vesicle.json for vesicle in recipient.inbox[index_start:index_stop]]}

    return jsonify(resp)
